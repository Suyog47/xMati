const _ = require('lodash')

/**
 * QnA Fallback Hook
 * 
 * This hook provides a fallback response when:
 * 1. No QnA match is found
 * 2. QnA confidence is too low
 * 3. User is not in a specific flow context
 * 
 * Instead of restarting the bot flow, it asks for elaboration
 */

const QNA_CONFIDENCE_THRESHOLD = 0.5 // Adjust based on your needs
const FALLBACK_MESSAGES = {
  en: [
    "Can you elaborate on your question?",
    "Could you provide more details about what you're looking for?",
    "I'd like to help you better. Can you rephrase your question?",
    "Could you be more specific about what you need help with?"
  ],
  // Add other languages as needed
}

const isInSpecificFlow = (event) => {
  const { currentFlow, currentNode } = event.state.context

  // Don't interfere if user is actively in ANY flow
  if (currentFlow && currentNode) {
    return true
  }

  // Check for specific flows that should never be interrupted
  const excludedFlows = [
    'skills/choice',
    'error',
    'timeout',
    'main'
  ]

  return excludedFlows.some(flow => currentFlow && currentFlow.includes(flow))
}

const hasFlowIntent = (event) => {
  // Check if the detected intent should trigger a flow
  const intent = event.nlu.intent
  
  // If there's a meaningful intent (not 'none') with decent confidence
  if (intent.name !== 'none' && intent.confidence >= 0.3) {
    return true
  }
  
  // Check if there are any flow-based suggestions already queued
  if (event.suggestions && event.suggestions.length > 0) {
    return event.suggestions.some(s => 
      s.source === 'flow' || 
      s.source === 'dialog' || 
      s.sourceDetails?.includes('flow') ||
      s.sourceDetails?.includes('node')
    )
  }
  
  return false
}

const hasQnAMatch = (event) => {
  // Check if QnA found any suggestions
  return event.suggestions &&
    event.suggestions.length > 0 &&
    event.suggestions.some(s => s.source === 'qna' && s.confidence >= QNA_CONFIDENCE_THRESHOLD)
}

const getRandomFallbackMessage = (language = 'en') => {
  const messages = FALLBACK_MESSAGES[language] || FALLBACK_MESSAGES.en
  const randomIndex = Math.floor(Math.random() * messages.length)
  return messages[randomIndex]
}

const shouldProvideFallback = (event) => {
  // Only handle text messages
  if (event.type !== 'text') {
    return false
  }

  // PRIORITY 1: Don't interfere if user is in any active flow
  if (isInSpecificFlow(event)) {
    return false
  }

  // PRIORITY 2: Check if there's a flow intent that should be processed
  // This handles the case where currentFlow/currentNode are undefined
  // but the system should still process flow logic
  if (hasFlowIntent(event)) {
    return false
  }

  // PRIORITY 3: Check if there are any non-QnA suggestions
  const hasFlowSuggestions = event.suggestions &&
    event.suggestions.length > 0 &&
    event.suggestions.some(s => s.source !== 'qna' && s.confidence >= 0.3)

  if (hasFlowSuggestions) {
    return false
  }

  // PRIORITY 4: Check if QnA found a good match
  const hasGoodQnAMatch = hasQnAMatch(event)
  if (hasGoodQnAMatch) {
    return false
  }

  // PRIORITY 5: Only provide fallback if nothing else can handle it
  const hasLowConfidenceIntent = event.nlu.intent.name === 'none' ||
    event.nlu.intent.confidence < 0.3

  const noQnAMatch = !hasQnAMatch(event)

  return hasLowConfidenceIntent && noQnAMatch
}

const provideFallbackResponse = async (event) => {
  const language = event.nlu.language || 'en'
  const fallbackMessage = getRandomFallbackMessage(language)

  // Create a fallback response payload
  const fallbackPayload = {
    type: 'text',
    text: fallbackMessage,
    markdown: true
  }

  // Add the fallback as a suggestion with medium confidence
  event.suggestions = event.suggestions || []
  event.suggestions.push({
    confidence: 0.7, // Medium confidence so it gets selected if no better match
    payloads: [fallbackPayload],
    source: 'qna-fallback',
    sourceDetails: 'QnA Fallback Hook'
  })

  // Optionally set a flag for analytics
  event.setFlag('QNA_FALLBACK_TRIGGERED', true)

  bp.logger.debug(`QnA Fallback triggered for message: "${event.preview}"`, {
    botId: event.botId,
    userId: event.target,
    intent: event.nlu.intent.name,
    confidence: event.nlu.intent.confidence
  })
}

// Main hook execution - runs directly when hook is triggered
(async () => {
  try {
    // Debug logging to understand execution flow
    bp.logger.debug('QnA Fallback Hook - Analyzing event', {
      botId: event.botId,
      messageType: event.type,
      currentFlow: event.state.context.currentFlow,
      currentNode: event.state.context.currentNode,
      intent: event.nlu.intent.name,
      intentConfidence: event.nlu.intent.confidence,
      hasFlowIntent: hasFlowIntent(event),
      isInSpecificFlow: isInSpecificFlow(event),
      suggestionsCount: event.suggestions ? event.suggestions.length : 0,
      suggestionSources: event.suggestions ? event.suggestions.map(s => s.source) : [],
      suggestionDetails: event.suggestions ? event.suggestions.map(s => s.sourceDetails) : []
    })

    if (shouldProvideFallback(event)) {
      await provideFallbackResponse(event)
    }
  } catch (error) {
    bp.logger.error('Error in QnA Fallback Hook:', error)
  }
})()